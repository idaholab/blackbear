/****************************************************************/
/*               DO NOT MODIFY THIS HEADER                      */
/*                       BlackBear                              */
/*                                                              */
/*           (c) 2017 Battelle Energy Alliance, LLC             */
/*                   ALL RIGHTS RESERVED                        */
/*                                                              */
/*          Prepared by Battelle Energy Alliance, LLC           */
/*            Under Contract No. DE-AC07-05ID14517              */
/*            With the U. S. Department of Energy               */
/*                                                              */
/*            See COPYRIGHT for full restrictions               */
/****************************************************************/

#ifdef NEML_ENABLED
#include "NEMLStressBase.h"

InputParameters
NEMLStressBase::validParams()
{
  InputParameters params = ComputeStressBase::validParams();
  params.addCoupledVar("temperature", 0.0, "Coupled temperature");
  return params;
}

NEMLStressBase::NEMLStressBase(const InputParameters & parameters)
  : ComputeStressBase(parameters),
    _hist(declareProperty<std::vector<Real>>(_base_name + "hist")),
    _hist_old(getMaterialPropertyOld<std::vector<Real>>(_base_name + "hist")),
    _mechanical_strain_old(
        getMaterialPropertyOldByName<RankTwoTensor>(_base_name + "mechanical_strain")),
    _stress_old(getMaterialPropertyOld<RankTwoTensor>(_base_name + "stress")),
    _energy(declareProperty<Real>(_base_name + "energy")),
    _energy_old(getMaterialPropertyOld<Real>(_base_name + "energy")),
    _dissipation(declareProperty<Real>(_base_name + "dissipation")),
    _dissipation_old(getMaterialPropertyOld<Real>(_base_name + "dissipation")),
    _temperature(coupledValue("temperature")),
    _temperature_old(coupledValueOld("temperature")),
    _inelastic_strain(declareProperty<RankTwoTensor>(_base_name + "inelastic_strain"))
{
}

void
NEMLStressBase::computeQpStress()
{
  // We must update:
  // 1) _stress
  // 2) _Jacobian_mult
  // 3) _elastic_strain
  // 4) _history

  // First do some declaration and translation
  double s_np1[6];
  double s_n[6];
  RankTwoTensorToNeml(_stress_old[_qp], s_n);

  double e_np1[6];
  RankTwoTensorToNeml(_mechanical_strain[_qp], e_np1);
  double e_n[6];
  RankTwoTensorToNeml(_mechanical_strain_old[_qp], e_n);

  double t_np1 = _t;
  double t_n = _t - _dt;

  double T_np1 = _temperature[_qp];
  double T_n = _temperature_old[_qp];

  double * h_np1 = (_model->nhist() > 0 ? &(_hist[_qp][0]) : nullptr);
  const double * const h_n = (_model->nhist() > 0 ? &(_hist_old[_qp][0]) : nullptr);

  double A_np1[36];

  double u_np1;
  double u_n = _energy_old[_qp];

  double p_np1;
  double p_n = _dissipation_old[_qp];

  double estrain[6];

  int ier;

  // Actually call the update
  ier = _model->update_sd(
      e_np1, e_n, T_np1, T_n, t_np1, t_n, s_np1, s_n, h_np1, h_n, A_np1, u_np1, u_n, p_np1, p_n);

  if (ier != neml::SUCCESS)
    throw MooseException("NEML stress update failed!");

  // Do more translation, now back to tensors
  NemlToRankTwoTensor(s_np1, _stress[_qp]);
  NemlToRankFourTensor(A_np1, _Jacobian_mult[_qp]);

  // Get the elastic strain
  ier = _model->elastic_strains(s_np1, T_np1, h_np1, estrain);

  if (ier != neml::SUCCESS)
    mooseError("Error in NEML call for elastic strain!");

  // Translate
  NemlToRankTwoTensor(estrain, _elastic_strain[_qp]);

  // For EPP purposes calculate the inelastic strain
  double pstrain[6];
  for (unsigned int i = 0; i < 6; ++i)
    pstrain[i] = e_np1[i] - estrain[i];

  NemlToRankTwoTensor(pstrain, _inelastic_strain[_qp]);

  // Store dissipation
  _energy[_qp] = u_np1;
  _dissipation[_qp] = p_np1;
}

void
NEMLStressBase::initQpStatefulProperties()
{
  ComputeStressBase::initQpStatefulProperties();

  // Figure out initial history
  _hist[_qp].resize(_model->nhist());

  if (_model->nhist() > 0)
  {
    int ier = _model->init_hist(&(_hist[_qp][0]));
    if (ier != neml::SUCCESS)
      mooseError("Error initializing NEML history!");
  }

  _energy[_qp] = 0.0;
  _dissipation[_qp] = 0.0;
}

void
NEMLStressBase::RankTwoTensorToNeml(const RankTwoTensor & in, double * const out)
{
  double inds[6][2] = {{0, 0}, {1, 1}, {2, 2}, {1, 2}, {0, 2}, {0, 1}};
  double mults[6] = {1.0, 1.0, 1.0, sqrt(2.0), sqrt(2.0), sqrt(2.0)};

  for (unsigned int i = 0; i < 6; ++i)
  {
    out[i] = in(inds[i][0], inds[i][1]) * mults[i];
  }
}

void
NEMLStressBase::NemlToRankTwoTensor(const double * const in, RankTwoTensor & out)
{
  double inds[6][2] = {{0, 0}, {1, 1}, {2, 2}, {1, 2}, {0, 2}, {0, 1}};
  double mults[6] = {1.0, 1.0, 1.0, sqrt(2.0), sqrt(2.0), sqrt(2.0)};

  for (unsigned int i = 0; i < 6; ++i)
  {
    out(inds[i][0], inds[i][1]) = in[i] / mults[i];
    out(inds[i][1], inds[i][0]) = in[i] / mults[i];
  }
}

void
NEMLStressBase::NemlToRankFourTensor(const double * const in, RankFourTensor & out)
{
  double inds[6][2] = {{0, 0}, {1, 1}, {2, 2}, {1, 2}, {0, 2}, {0, 1}};
  double mults[6] = {1.0, 1.0, 1.0, sqrt(2.0), sqrt(2.0), sqrt(2.0)};

  for (unsigned int i = 0; i < 6; ++i)
  {
    for (unsigned int j = 0; j < 6; ++j)
    {
      out(inds[i][0], inds[i][1], inds[j][0], inds[j][1]) = in[i * 6 + j] / (mults[i] * mults[j]);
      out(inds[i][1], inds[i][0], inds[j][0], inds[j][1]) = in[i * 6 + j] / (mults[i] * mults[j]);
      out(inds[i][0], inds[i][1], inds[j][1], inds[j][0]) = in[i * 6 + j] / (mults[i] * mults[j]);
      out(inds[i][1], inds[i][0], inds[j][1], inds[j][0]) = in[i * 6 + j] / (mults[i] * mults[j]);
    }
  }
}

std::string
compareVectorsOfStrings(const std::vector<std::string> & strList1,
                        const std::vector<std::string> & strList2)
{
  std::string missingNames;
  for (auto & str1 : strList1)
  {
    bool found = false;
    for (auto & str2 : strList2)
    {
      if (str1 == str2)
      {
        found = true;
        break;
      }
    }
    if (!found)
      missingNames += str1 + " ";
  }
  return missingNames;
}

std::string
parseXmlIntoString(const FileName & fname)
{
  std::ifstream inputStream(fname.c_str());
  std::string line, xmlStringForNeml;
  while (getline(inputStream, line))
  {
    if (line.find("material") == std::string::npos)
    {
      xmlStringForNeml += line;
    }
  }
  return xmlStringForNeml;
}

std::vector<std::string>
listOfVariablesInXml(const FileName & fname)
{
  std::ifstream inputStream(fname.c_str());
  if (!inputStream)
    mooseError("Can't open ", fname);
  std::vector<std::string> xmlVariableNames;
  std::string line;
  while (getline(inputStream, line))
  {
    size_t open = line.find("{");
    size_t close = line.find("}");
    if (open != std::string::npos)
      xmlVariableNames.push_back(line.substr(open + 1, close - (open + 1)));
  }
  return xmlVariableNames;
}

void
errorCheckVariableNamesFromInputFile(const std::vector<std::string> & nemlNames,
                                     const FileName & fname)
{
  std::vector<std::string> xmlNames = listOfVariablesInXml(fname);
  std::string extraNemlNames = compareVectorsOfStrings(nemlNames, xmlNames);
  std::string extraXmlNames = compareVectorsOfStrings(xmlNames, nemlNames);
  if (!extraNemlNames.empty() || !extraXmlNames.empty())
  {
    std::stringstream msg;
    msg << "Mismatched NEML variable names between xml and BlackBear input file.\n"
        << "  BlackBear variable names not found in xml file: " << extraNemlNames
        << "\n  NEML xml variable names not found in BlackBear input file: " << extraXmlNames;
    mooseError(msg.str());
  }
}

std::string
NEMLStressBase::parseAndReplaceXmlVariables(const std::vector<std::string> & nemlNames,
                                            const std::vector<Real> & nemlValues,
                                            const FileName & fname) const
{
  errorCheckVariableNamesFromInputFile(nemlNames, fname);
  std::string xmlStringForNeml = parseXmlIntoString(fname);
  for (auto i = 0; i < nemlNames.size(); ++i)
  {
    std::string varName = nemlNames[i];
    Real varValue = nemlValues[i];
    size_t posOfFirstCurlyBrace = xmlStringForNeml.find(varName) - 1;
    size_t varLenghtWithBothCurlyBraces = varName.length() + 2;
    xmlStringForNeml.replace(
        posOfFirstCurlyBrace, varLenghtWithBothCurlyBraces, std::to_string(varValue));
  }
  return xmlStringForNeml;
}

#endif // NEML_ENABLED
